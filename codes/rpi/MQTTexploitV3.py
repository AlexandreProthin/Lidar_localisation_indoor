import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
import numpy as np
import time
import paho.mqtt.client as mqtt
import matplotlib.animation as animation
from sklearn.cluster import DBSCAN
from sklearn.preprocessing import StandardScaler
from sklearn.preprocessing import normalize
from sklearn.decomposition import PCA
from sklearn import metrics
from sklearn.datasets import make_blobs
from sklearn import decomposition
from sklearn import datasets

"""
Codes permettant de réaliser sur la RPI:
    - une communication avec le serveur
    - une série d'acquisition 
    - un prétraitement des données acquises
"""

"""        initialisation communication serveur            """

# Successful Connection Callback
def on_connect(client, userdata, flags, rc):
    print('Connected with result code '+str(rc))
    client.subscribe('\showroom\Lidar')

tab=[]
# Message delivery callback
def on_message(client, userdata, msg):
    print(str(msg.payload.decode("utf-8")))
    #tab = append_limit(value, list)

def append_limit(value, list):
    newList = list
    if(len(list)>=300):
        del list[0]
    newList.append(value)
    #return newList

client = mqtt.Client()

# Set callback handler
client.on_connect = on_connect
client.on_message = on_message

# Set up connection
client.connect('10.100.100.117', 443, 60)
# Publish message
client.publish('\showroom\Lidar',payload='SUR',qos=0)

client.loop_forever()



"""         Traitement des données         """
def PolarToCart(angle,distance):
    """
    Changement de système de coordonnées, polaire vers cartésien
    """
    x = distance*np.cos(angle*((2*np.pi)/360))
    y = distance*np.sin(angle*((2*np.pi)/360))
    return [x,y]

def animate(i, xs, ys):
    """ 
    Tracé du résultat de la détection
    """
    # Limit x and y lists to 20 items
    #xs = xs[-20:]
    #ys = ys[-20:]

    # Draw x and y lists
    ax.clear()
    ax.scatter(xs, ys)

    # Format plot
    plt.xticks(rotation=45, ha='right')
    plt.subplots_adjust(bottom=0.30)
    plt.title('Lidar')
    plt.ylabel('Distance')

def dbscan(res):
    """ 
    L'utiliation de la méthode de cluste DBSCAN paermet de grouper les ammas de points 
    """
    # Numpy array of all the cluster labels assigned to each data point
    res = np.array(res)
    std = StandardScaler()
    X = std.fit_transform(res)
    # le réglage des paramètres interne à déjà été réalisé mais peut être modifié pour un cas spécifique
    db = DBSCAN(eps=0.2, min_samples=20).fit(X)
    core_samples_mask = np.zeros_like(db.labels_, dtype=bool)
    core_samples_mask[db.core_sample_indices_] = True
    labels = db.labels_
    # Black removed and is used for noise instead.
    unique_labels = set(labels)
    results, cart, temp = [], [], []
    # association des labels aux clusters
    for k in zip(unique_labels):
        class_member_mask = labels == k
        Scluster = std.inverse_transform(X[class_member_mask & core_samples_mask])
        results.append(Scluster)
       

        for i in results:
            for j in range(len(i)):
                a = PolarToCart(i[j][0], i[j][1])
                temp.append(a)
            temp = np.array(temp)
            cart.append(temp)
            temp = []
       
    return cart














